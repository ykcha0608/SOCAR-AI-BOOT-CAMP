import torch
import torch.nn as nn
# Hyper-parameters 사람이 직접 정해줘야하는 파라미터
input_size = 1
output_size = 1
num_epochs = 100  #전제 트레이닝 셋을 한번 보는 것
learning_rate = 0.1  #알파값 조정. 스텝 사이즈 조정
# Linear regression model, y = Wx+b
model = nn.Linear(input_size, output_size) 
# Loss and optimizer
criterion = nn.MSELoss()
optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)  
print(x_data.shape, y_data.shape)  #몇 열 몇 행인지 보는 것
if len(x_data.shape)==1 and len(y_data.shape)==1:
  x_data = np.expand_dims(x_data, axis=-1)
  y_data = np.expand_dims(y_data, axis=-1)
print(x_data.shape, y_data.shape)
# Train the model
for epoch in range(num_epochs):
    # Convert numpy arrays to torch tensors
    inputs = torch.from_numpy(x_data)
    targets = torch.from_numpy(y_data)

    # Predict outputs with the linear model.
    outputs = model(inputs)
    loss = criterion(outputs, targets)  #MSE error 계산
    
    # compute gradients and update
    optimizer.zero_grad()   #optimizer에서 갖고 있던 미분값
    loss.backward()  #미분 계산
    optimizer.step()  #계산된 grad값과 러닝메이트값으로 제로웨이트를 업데이트

    #반복하면서 loss 줄어드는 것 확인
    
    if (epoch+1) % 5 == 0:
        print ('Epoch [{}/{}], Loss: {:.4f}'.format(epoch+1, num_epochs, loss.item()))
# Plot the graph
predicted = model(torch.from_numpy(x_data)).detach().numpy()
plt.plot(x_data, y_data, 'ro', label='Original data')
plt.plot(x_data, predicted, label='Fitted line')
plt.legend()
plt.show()
